# LOGIC_16_POLICY_CAPTURE.yaml

meta:
  owner: "AI Opener"
  version: "2.0.0"
  last_updated: "2025-12-11"
  purpose: "AI policy enforcement mechanics and feedback-to-policy loop (SSOT)"
  notes: "v2.0 - Policy capture, storage, and retrieval integration"
  tags: [logic, policy, ssot]

enforcement_actions:
  block:
    applies_to: ["prohibited_use_cases", "blocked_topics"]
    behavior: "Return error, do not execute"
  redact:
    applies_to: ["confidential_information", "pii_when_not_allowed"]
    behavior: "Strip content, continue with sanitized output"
  require_hitl:
    applies_to: ["approval_required_for items", "external_communication", "sensitive_topics"]
    behavior: "Pause, trigger HITL per LOGIC_09_INTERFACE#hitl_triggers"
  library_scope_violation:
    applies_to: ["Cross-org retrieval attempts", "Cross-client retrieval when client scope applies", "Non-allowlisted library access attempts", "Ineligible library access attempts"]
    behavior: "Block retrieval, return empty result set, capture policy event"
    trace_event_type: "library_scope_violation"
    trace_fields: ["attempted_library_id", "runtime_org_id", "runtime_client_id", "violation_type", "timestamp"]
    reference: "$ref: LOGIC_05_RAG_MECHANICS#libraries_retrieval.mandatory_metadata_filtering.enforcement"

policy_evaluation:
  precedence:
    order: ["LOGIC_12_GOVERNANCE.minimums", "ORG.ai_policy", "CLIENT.ai_policy"]
    rule: "CLIENT > ORG > LOGIC minimums (most restrictive wins)"
    note: "LOGIC_12_GOVERNANCE.minimums are immutable safety floors"
  scope:
    - "USE_CASES: checked at activation"
    - "WORKFLOWS: checked at activation and phase entry"
    - "LIBRARIES: checked at retrieval time (scope + allowlist validation)"
    - "Content generation: checked before output"
    - "Data handling: checked before processing"
  merge_behavior:
    strategy: "$ref: LOGIC_02_RETRIEVAL#override_rules.strategies.most_restrictive_wins"
    arrays: "Union (CLIENT adds to ORG restrictions)"
    booleans: "Most restrictive value wins"

policy_capture_overview:
  flow:
    1_feedback_event:
      sources: ["HITL approvals/rejections", "Review comments", "Explicit policy statements", "Quality gate failures with correction", "Preference expressions"]
    2_pattern_detection:
      criteria: ["Repeated pattern (3+ occurrences)", "Explicit policy statement", "Critical correction", "Stakeholder directive"]
    3_policy_extraction:
      output: "$ref: #policy_schema"
    4_policy_validation:
      requires: "human_confirmation"
    5_policy_storage:
      locations: "$ref: #policy_storage"
    6_retrieval_integration:
      mechanism: "$ref: #retrieval_integration"

feedback_sources:
  sources:
    hitl_decisions:
      policy_signals: ["Approval with modification", "Rejection with reason", "Escalation decisions", "Override of AI recommendation"]
      capture_fields: ["decision", "reason", "modification_made", "context"]
    review_feedback:
      policy_signals: ["Consistent style corrections", "Repeated content changes", "Terminology preferences", "Format preferences"]
      capture_fields: ["original_content", "corrected_content", "feedback_comment", "category"]
    explicit_policies:
      triggers: ["Always...", "Never...", "We prefer...", "Our policy is...", "Don't mention..."]
      capture_fields: ["statement", "context", "source_user", "timestamp"]
    quality_corrections:
      policy_signals: ["Repeated gate failures", "Systematic corrections", "Evidence updates"]
      capture_fields: ["gate_failed", "correction_made", "root_cause"]
    library_scope_events:
      policy_signals: ["Attempted cross-org access", "Attempted cross-client access", "Non-allowlisted library access", "Eligibility gate failures"]
      capture_fields: ["violation_type", "attempted_library_id", "runtime_scope", "timestamp", "use_case_context"]
    preference_expressions:
      policy_signals: ["Consistent selections", "Rejected alternatives", "Positive reactions"]
      capture_fields: ["preference_type", "preferred_option", "rejected_options", "frequency"]

policy_schema:
  required_fields:
    id: { type: "string", pattern: "pol_{scope}_{category}_{nnn}" }
    type: { type: "enum", values: ["directive", "preference", "constraint", "guidance"], descriptions: { directive: "Must follow (hard rule)", preference: "Should follow unless conflict", constraint: "Boundary not to cross", guidance: "Suggested approach" } }
    scope: { type: "enum", values: ["org", "client", "project", "user"] }
    category: { type: "string", examples: ["style", "content", "terminology", "format", "process", "competitor", "compliance"] }
    statement: { type: "string", max_length: 500 }
    rationale: { type: "string" }
  optional_fields:
    source_feedback: { type: "array" }
    effective_date: { type: "date", format: "YYYY-MM-DD" }
    expiry_date: { type: "date", format: "YYYY-MM-DD" }
    approved_by: { type: "string" }
    tags: { type: "array", items: "string", validation: "$ref: LOGIC_03_TAXONOMY#valid_tags" }
    supersedes: { type: "string" }
    exceptions: { type: "array" }

pattern_detection:
  detection_rules:
    frequency_threshold:
      thresholds: { style_correction: 3, content_change: 3, rejection_pattern: 2, explicit_statement: 1 }
    recency_window: { default_days: 30 }
    similarity_threshold: { method: "semantic_similarity", threshold: 0.8 }
  detection_triggers:
    immediate:
      conditions: ["Explicit policy statement", "Critical compliance issue", "Direct directive from approver"]
    accumulated:
      conditions: ["Frequency threshold met", "Consistent pattern across time"]
  notification:
    on_pattern_detected:
      message: "Policy pattern detected: {summary}"
      action: "Request confirmation"
      recipient: "Primary contact"

policy_storage:
  storage_locations:
    org_policies: { path: "ORG.policies", scope: "org" }
    client_policies: { path: "CLIENT.policies", scope: "client" }
    project_policies: { path: "CLIENT.projects.{project_id}.policies", scope: "project" }
  storage_format:
    structure: "Array of policy objects"
    schema: "$ref: #policy_schema"
  indexing:
    for_retrieval:
      index_fields: ["category", "type", "tags"]
      vector_embedding: true
      namespace_pattern: "{scope}_policies"

retrieval_integration:
  reference: "$ref: LOGIC_05_RAG_MECHANICS#retrieval_pipeline"
  injection_points:
    context_assembly: { stage: "5_result_assembly", priority: "high" }
    query_expansion: { stage: "1_query_processing", method: "Add policy categories to query" }
  always_retrieve:
    conditions: ["CLIENT context active --> include client policies", "ORG context active --> include org policies", "Project active --> include project policies"]
  retrieval_boost: { boost_factor: 1.5 }
  freshness: { max_age: "none (policies don't expire by age)", expiry_check: "Check expiry_date field" }
  conflict_resolution:
    priority_order:
      1: "directive over preference over guidance"
      2: "More specific scope over broader"
      3: "More recent over older"
    on_conflict: "Use highest priority, log conflict"

policy_lifecycle:
  states:
    draft: { actions: ["confirm", "edit", "discard"] }
    active: { actions: ["edit", "suspend", "expire", "supersede"] }
    suspended: { actions: ["reactivate", "expire"] }
    expired: { actions: ["reactivate"] }
  transitions:
    draft_to_active: { requires: "human_confirmation" }
    active_to_suspended: { requires: "human_action" }
    active_to_expired: { trigger: "expiry_date reached OR manual expiry" }
    superseded: { trigger: "New policy with supersedes reference" }
  review: { frequency: "quarterly", notification: "Policy review due for {client}", action: "Review and confirm/update/expire policies" }
  audit:
    track: ["creation", "modifications", "state_changes", "applications"]
    retention: "$ref: LOGIC_11_TRACE#retention"

policy_application:
  application_points:
    content_generation: { policies_checked: ["style", "terminology", "content constraints"] }
    quality_gates: { policies_checked: ["compliance", "format", "required elements"] }
    review: { policies_checked: ["all applicable policies"] }
  enforcement:
    directive: { enforcement: "block if violated" }
    preference: { enforcement: "warn if violated" }
    constraint: { enforcement: "block if violated" }
    guidance: { enforcement: "log if not followed" }
  logging:
    on_application: { log_event: "policy_applied", fields: ["policy_id", "context", "outcome"] }
    on_violation: { log_event: "policy_violation", fields: ["policy_id", "violation_details", "action_taken"] }
