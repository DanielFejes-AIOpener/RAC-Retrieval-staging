# LOGIC_13_INTEGRATION.yaml

meta:
  owner: "AI Opener"
  version: "2.0.0"
  last_updated: "2025-12-11"
  purpose: "External system integration patterns (SSOT)"
  notes: "v2.0 - Integration templates with demo mode simulation"
  tags: [logic, integration, api, simulation, ssot]

integration_categories:
  categories:
    analytics:
      examples: ["Google Analytics", "Adobe Analytics", "Mixpanel", "Amplitude"]
      common_operations: ["fetch_metrics", "fetch_reports", "create_events"]
    crm:
      examples: ["Salesforce", "HubSpot", "Pipedrive", "Microsoft Dynamics"]
      common_operations: ["fetch_contacts", "update_contact", "create_activity", "fetch_deals"]
    marketing_automation:
      examples: ["HubSpot Marketing", "Marketo", "Mailchimp", "ActiveCampaign"]
      common_operations: ["create_campaign", "fetch_performance", "update_lists", "send_email"]
    social_media:
      examples: ["LinkedIn", "Twitter/X", "Facebook/Meta", "Instagram"]
      common_operations: ["publish_post", "fetch_analytics", "schedule_content"]
    content_management:
      examples: ["WordPress", "Contentful", "Sanity", "DAM systems"]
      common_operations: ["create_content", "update_content", "fetch_assets", "publish_content"]
    advertising:
      examples: ["Google Ads", "LinkedIn Ads", "Meta Ads", "Programmatic DSPs"]
      common_operations: ["fetch_performance", "create_campaign", "update_targeting"]
    storage:
      examples: ["Google Drive", "Dropbox", "SharePoint", "S3"]
      common_operations: ["upload_file", "download_file", "list_files", "share_file"]

integration_template:
  schema:
    required_fields:
      id: { type: "string", pattern: "int_{category}_{platform}" }
      name: { type: "string" }
      category: { type: "enum", values: "$ref: #integration_categories.categories" }
      auth: { type: "object", properties: { method: { type: "enum", values: ["oauth2", "api_key", "basic", "jwt"] }, config_ref: { type: "string" } } }
      base_url: { type: "string", format: "uri_template" }
      operations: { type: "array", items: { properties: { name: "string", method: "enum: GET, POST, PUT, DELETE, PATCH", path: "string", input_schema: "object", output_schema: "object" } } }
    optional_fields:
      rate_limits: { type: "object", reference: "$ref: LOGIC_10_TOOLS_CORE#rate_limiting" }
      retry_config: { type: "object", reference: "$ref: LOGIC_10_TOOLS_CORE#resilience_patterns.retry" }
      demo_mock: { type: "object" }

authentication_patterns:
  patterns:
    oauth2:
      flows:
        authorization_code: { use_case: "User-authorized access" }
        client_credentials: { use_case: "Server-to-server authentication" }
        refresh_token: { implementation: "Auto-refresh before expiry" }
      token_storage:
        location: "Secure credential store"
        encryption: "required"
        reference: "CLIENT.credentials OR ORG.credentials"
    api_key:
      header: "Authorization: Bearer {key} OR X-API-Key: {key}"
      storage:
        location: "Environment variable or secret store"
        never: "Hardcode in configuration"
    basic:
      header: "Authorization: Basic {base64(user:pass)}"
      use_case: "Legacy systems, simple APIs"
    jwt:
      implementation: ["Generate JWT with claims", "Sign with private key", "Include in Authorization header"]

demo_mode_simulation:
  behavior:
    when_demo_mode_true: ["No real API calls", "Use mock responses", "Simulate latency", "Track as demo operations"]
    mock_response_sources:
      1: "Integration-specific demo_mock configuration"
      2: "DEMO_00_SESSION.integrations.mocks"
      3: "Generic mock response generator"
  mock_configuration:
    schema:
      operation: { type: "string" }
      response: { type: "object" }
      latency_ms: { type: "integer" }
      error_rate: { type: "number" }
  simulation_flags:
    include_in_trace: true
    mark_as_simulated: true
    validate_input: true

integration_error_handling:
  error_categories:
    auth_failure:
      codes: [401, 403]
      actions: ["Attempt token refresh (if oauth2)", "Log authentication failure", "Escalate if refresh fails"]
      recovery: "retry_with_new_token"
    rate_limit:
      codes: [429]
      actions: ["Read Retry-After header", "Queue for later execution", "Apply backoff"]
      recovery: "retry_with_backoff"
    server_error:
      codes: [500, 502, 503, 504]
      actions: ["Apply retry pattern", "Try fallback if available", "Degrade gracefully"]
      recovery: "$ref: LOGIC_10_TOOLS_CORE#resilience_patterns"
    client_error:
      codes: [400, 404, 422]
      actions: ["Log request details", "Do not retry", "Surface error to caller"]
      recovery: "none"
    timeout:
      actions: ["Cancel request", "Apply retry with backoff", "Try fallback if available"]
      recovery: "$ref: LOGIC_10_TOOLS_CORE#resilience_patterns.retry"
  fallback_strategies:
    strategies:
      cached_data: { applicability: "Read operations", staleness_warning: true }
      degraded_operation: { applicability: "Optional integrations", logging: "enhanced" }
      alternative_integration: { applicability: "When backup configured" }
      human_escalation: { applicability: "Critical operations" }
    selection:
      order: ["cached_data", "alternative_integration", "degraded_operation", "human_escalation"]

data_transformation:
  patterns:
    normalize:
      use_case: "Inbound data from integrations"
      steps: ["Validate against expected schema", "Map fields to RAC standard names", "Apply type coercion", "Handle missing/null values"]
    denormalize:
      use_case: "Outbound data to integrations"
      steps: ["Map RAC fields to external names", "Apply format transformations", "Validate against external schema"]
    enrich:
      use_case: "Derived data"
      examples: ["Calculate percentages", "Add timestamps", "Generate IDs"]
  field_mapping:
    schema: { rac_field: "string", external_field: "string", transform: "string (optional)", default: "any (optional)" }

webhook_handling:
  security:
    verification: ["Validate signature/HMAC", "Verify source IP (if applicable)", "Check timestamp freshness"]
    rate_limiting: { enabled: true, max_per_minute: 100 }
  processing:
    acknowledgment: ["Return 200 immediately", "Process asynchronously"]
    idempotency: ["Store event IDs", "Deduplicate on replay"]
    ordering: ["Handle out-of-order events", "Use timestamps for sequencing"]
  error_handling:
    on_processing_failure: ["Queue for retry", "Log with full payload", "Alert after max retries"]
